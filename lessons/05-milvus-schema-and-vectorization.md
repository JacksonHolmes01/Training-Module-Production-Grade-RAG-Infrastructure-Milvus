# Lesson 5 — Milvus Schema & Vectorization

---

## Learning Objectives

By the end of this lesson, you will be able to:

- Explain what a **Milvus collection schema** is and why it differs from Qdrant.
- Explain **embeddings** in beginner-friendly language.
- Verify Milvus and the embedding model are healthy from inside Docker.
- Safely extend a collection schema with a new field.
- Rebuild and validate ingestion without breaking retrieval.
- Understand the Milvus **collection lifecycle** (create → index → load → search).

---

# Step 1 — Mental Model: What's Actually Happening

Milvus stores two things per document:

- **Scalar fields (columns)** → Your structured metadata (title, url, source, tags, etc.)
- **Vector field** → Numeric embeddings representing semantic meaning

Unlike Qdrant's schemaless payload approach, Milvus requires you to **declare a typed schema upfront**.  This is closer to a relational database — you must define field names and types before inserting data.

The schema in this lab is defined in `ingestion-api/app/milvus_client.py` inside `_build_schema()`.

That vector enables **semantic search**. Instead of matching keywords, Milvus retrieves documents based on meaning by comparing vector similarity.

---

### System Flow

```
User → Edge (NGINX) → Ingestion API → Milvus
                    ↳ Embedding Model (inside API)
```

> In production systems, embeddings are often generated by a separate model service.
> In this lab, embeddings are generated directly inside the ingestion API to simplify
> deployment and improve compatibility across systems.

---

# Step 2 — The Milvus Collection Lifecycle

Milvus requires **four distinct steps** before a collection is queryable.
This is fundamentally different from Qdrant, where a collection is immediately
searchable after creation.

```
1. Create collection (define schema)
2. Create index (choose algorithm: HNSW, IVF_FLAT, etc.)
3. Load collection (move data into memory)
4. Search / Insert
```

This design is intentional: Milvus is built for large-scale, high-throughput
production deployments where memory management matters.

**Why does this matter for you?**

If you call `collection.search()` before `collection.load()`, you will get an
error. The `ensure_collection()` function in `milvus_client.py` handles this
automatically for you — but understanding why is part of operating a real system.

---

## 2.1 Check Milvus Readiness

We do NOT expose Milvus to localhost. Everything runs inside Docker's internal network.

```bash
docker exec -i ingestion-api python - <<'PY'
from pymilvus import connections, utility
connections.connect(host="milvus", port=19530)
print("Server version:", utility.get_server_version())
PY
```

### Expected Output

```
Server version: v2.4.x
```

If the test fails:

```bash
docker compose logs milvus --tail=200
docker compose logs milvus-etcd --tail=50
docker compose logs milvus-minio --tail=50
```

> **Important:** Milvus depends on **etcd** (metadata store) and **MinIO** (object storage).
> If either is unhealthy, Milvus will not start.  Check all three service logs.

---

## 2.2 Verify the Collection Exists and Is Loaded

```bash
docker exec -i ingestion-api python - <<'PY'
import os
from pymilvus import connections, utility, Collection

connections.connect(host="milvus", port=19530)
col_name = os.getenv("MILVUS_COLLECTION", "LabDoc")

if utility.has_collection(col_name):
    col = Collection(col_name)
    col.load()
    stats = col.get_collection_stats()
    print(f"Collection '{col_name}' exists | row_count={stats.get('row_count', 'unknown')}")
else:
    print(f"Collection '{col_name}' does NOT exist yet. Run /ingest first.")
PY
```

---

# Step 3 — Milvus Schema vs Qdrant Payload

This is the most important architectural difference in this lab.

| Concept                  | Qdrant                                | Milvus                                  |
|--------------------------|---------------------------------------|------------------------------------------|
| Metadata storage         | Schemaless JSON payload               | Typed VARCHAR / INT64 / FLOAT columns   |
| Schema migration         | Never required                        | Required when adding new fields         |
| Adding a new field       | Just POST it — Qdrant stores anything | Must update schema and recreate collection |
| Field type enforcement   | None                                  | Strict — wrong type = insert error      |
| Index                    | Built automatically                   | Must be explicitly created              |
| Load step before search  | Not needed                            | Required (`collection.load()`)           |

---

# Step 3.1 — Update the API Request Model (`schemas.py`)

Your API validation model must stay aligned with what the vector DB expects.

Open the file:

```bash
nano ingestion-api/app/schemas.py
```

Modify the `ArticleIn` model to add a `tags` field:

```python
class ArticleIn(BaseModel):
    title: str
    url: str
    source: str
    published_date: str
    text: str
    tags: list[str] = []
```

Save the file (`Ctrl+O`, `Enter`, `Ctrl+X`).

---

# Step 3.2 — Milvus Schema Change (Collection Recreation Required)

Unlike Qdrant where new payload fields require zero migration, Milvus requires you to
**drop and recreate** the collection when adding new schema fields.

This is a production-grade lesson: **schema changes in Milvus are destructive**.

In production systems you would:
1. Create a new collection with the new schema
2. Migrate data from old to new collection
3. Swap the collection name in your service config
4. Drop the old collection

For this lab, we can drop and recreate because our data is small and re-ingested easily.

**View the current schema:**

```bash
docker exec -i ingestion-api python - <<'PY'
import os
from pymilvus import connections, Collection, utility

connections.connect(host="milvus", port=19530)
col_name = os.getenv("MILVUS_COLLECTION", "LabDoc")
if utility.has_collection(col_name):
    col = Collection(col_name)
    print(col.schema)
PY
```

**After modifying `milvus_client.py` with a new field, drop and recreate:**

```bash
docker exec -i ingestion-api python - <<'PY'
import os
from pymilvus import connections, utility

connections.connect(host="milvus", port=19530)
col_name = os.getenv("MILVUS_COLLECTION", "LabDoc")
if utility.has_collection(col_name):
    utility.drop_collection(col_name)
    print(f"Dropped collection: {col_name}")
PY
```

Then rebuild and re-ingest (Step 3.4 and 3.5).

> **Why does this matter?**
> Milvus's strict schema model is a tradeoff: you gain type safety and
> query-time efficiency at the cost of migration complexity.  Qdrant's
> schemaless payload is more flexible but offers less compile-time safety.

---

# Step 3.3 — Update Sample Data

Open the sample data file:

```bash
nano data/sample_articles.jsonl
```

Modify one entry to include tags:

```json
{"title":"Example","url":"https://example.com","source":"Manual","published_date":"2026-02-13","text":"Sample text for schema testing.","tags":["lab1","schema-change"]}
```

Save and close.

---

# Step 3.4 — Rebuild the API

```bash
docker compose up -d --build ingestion-api
```

Wait for: `Application startup complete.`

---

# Step 3.5 — Re-Run Ingestion

```bash
EDGE_API_KEY=$(grep -E '^EDGE_API_KEY=' .env | cut -d= -f2-)
curl -i -X POST "http://localhost:8088/ingest" \
  -H "Content-Type: application/json" \
  -H "X-API-Key: $EDGE_API_KEY" \
  -d '{
    "title": "Tagged Doc",
    "url": "https://example.com/tagged",
    "source": "Manual",
    "published_date": "2026-02-13",
    "tags": ["lab1", "schema-change"],
    "text": "This document proves schema changes can be applied safely."
  }'
```

Expected output:

```json
{
  "status": "ok",
  "milvus": {
    "result": "inserted",
    "id": "..."
  }
}
```

---

# Step 3.6 — Verify Retrieval Still Works

```bash
EDGE_API_KEY=$(grep -E '^EDGE_API_KEY=' .env | cut -d= -f2-)
curl -sS -G "http://localhost:8088/debug/retrieve" \
  -H "X-API-Key: $EDGE_API_KEY" \
  --data-urlencode "q=schema changes applied safely" | python -m json.tool
```

---

# Optional — Create a Scalar Index on `tags`

For high-cardinality fields like tags, Milvus supports scalar indexes to speed up
filtered searches.

```bash
docker exec -i ingestion-api python - <<'PY'
import os
from pymilvus import connections, Collection

connections.connect(host="milvus", port=19530)
col = Collection(os.getenv("MILVUS_COLLECTION", "LabDoc"))
col.create_index(field_name="tags", index_name="tags_index")
print("Scalar index created on 'tags'")
PY
```

---

# Checkpoints

You have:

- Understood Milvus's explicit schema and lifecycle model
- Extended the API validation model safely
- Experienced a schema migration (drop + recreate)
- Rebuilt containers and re-ingested documents
- Confirmed semantic retrieval still works after schema change

---

# Why This Matters

In production systems:

- Milvus schema changes require planned migrations (not in-place alterations)
- The collection lifecycle (create → index → load) must be managed explicitly
- Scalar indexes on filter fields improve filtered-search performance at scale
- Qdrant's schemaless model trades safety for flexibility — neither is universally better

---

[Lesson 6](06-ingestion-api-validation-and-ingest.md)
